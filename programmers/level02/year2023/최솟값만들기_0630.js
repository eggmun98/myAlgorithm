// 1. 문제와 이해
// 두 배열의 숫자를 하나씩 뽑아서 곱하면서 더하여 최솟값을 구해야 합니다.
// 모든 경우의 수를 구하는 대신 효율적인 방법을 이용해야 합니다.
// 하나의 배열은 제일 작은 값 다른 배열은 제일 큰 값을 곱해서 더하는 방식으로 풀어야 합니다.

// 2. 계획
// A 배열을 오름차순으로 정렬합니다.
// B 배열을 내림차순으로 정렬합니다.
// 반복문을 이용하여 새로운 배열들의 요소들을 곱하고 더합니다.

// 3-1. 풀이
function solution(a, b) {
  newA = a.sort((a, b) => a - b);
  newB = b.slice().sort((a, b) => b - a);
  answer = 0;
  for (let i = 0; i < newA.length; i++) {
    answer += newA[i] * newB[i];
  }
  return answer;
}

// 3-2. 풀이2
function solution(a, b) {
  newA = a.sort((a, b) => a - b);
  newB = b.sort((a, b) => b - a);
  return newA.reduce((a, b, c) => a + b * newB[c], 0);
} // answer 변수를 없애고 reduce를 이용하여 바로 리턴값을 출력하는 방법의 풀이이다.

// 4. 회고
// 처음 모든 경우의 수를 계산해서 최종 값을 리턴을 할까 고민을 하였다.
// 하지만 너무 비효율적인 방법인 거 같아서 효율적인 방법을 찾아 고민을 하였다.
// 내가 생각한 방법은 한 배열에서 가장 작은 값과 다른 배열에서 가장 큰 값을 곱해서 더하는 방식이였다.
// 이 방식이면 각 배열들의 곱해서 더한 값의 최솟값을 구할 수 있었다.
// 이제 이 방법을 코드로 바꾸는게 어려웠었다.
// Math.min 메소드를 이용하거나 reduce를 이용하면서 많이 막혔었다.
// 그래도 포기하지 않고 계속 코드를 작성을 하니 문제를 풀수 있게 되었다.
// 이 문제를 풀면서 포기하지 않고 계속 시도를 하면 문제를 풀수 있다는 것을 알게 되었다.
// 앞으로 더 효율적으로 문제를 풀수 있게 노력을 해야겠다!!
