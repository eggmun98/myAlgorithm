/* 문제와 이해
n 명의 친구들이 결혼식에 온다.
가장 많은 시간대에 존재하는 친구들의 수를 세야 한다.
단 끝나는 시간은 존재하지 않는 시간으로 간주한다.
반대로 시작하는 시간은 존재한다고 판단한다
 */

/* 계획
아래처럼 타임라인을 그려보면 최대 같은 시간대에 존재하는 횟수는 2명이다.
|-------|
5       14
    |-------|
    12      15
        |--------|
        14       18
            |---------|
            15        20
                      |---------|
                      20        30
이 횟수를 세기 위해 코드로 표현하자면
타임라인이라는 배열을 만들어서 시작 시간대와 끝나는 시간대를 각각 배열에 푸시 한다.
시작 시간대에는 s라는 문자를 같이 넣고 끝나는 시간대에는 e라는 문자를 넣어
각 시간대가 시작인지, 끝나는 시간인지 판단할 수 있게 한다.
이렇게 되면 배열의 길이는 n * 2이다.
그리고 타임라인의 배열을 정렬을 해야 한다.
타임라인 배열에는 시간이 낮은 거부터 정렬을 하는데,
만약 시간이 같은 경우는 s보다는 e의 시간대를 먼저 넣는다.
왜나하면 e의 시간대를 먼저 넣어야 최대 횟수를 정확히 셀 수 있기 때문이다.
s를 넣으면 존재하는 시간대가 3명이 넘어가 정확하지 않다.
이렇게 정렬이 끝나고 나서는
반복문을 돌린다. 
s를 만나는 경우는 count++를 해주고,
e를 만나는 경우는 count--를 해준다.
그리고 반복문이 끝날 때마다 answer와 count를 비교해서 
가장 큰 숫자만 남긴다.



*/

/* 풀이1
 */
function solution(arr) {
  const timeLine = [];

  for (x of arr) {
    timeLine.push([x[0], "s"]);
    timeLine.push([x[1], "e"]);
  }

  timeLine.sort((a, b) => {
    if (a[0] === b[0]) {
      return a[1].charCodeAt() - b[1].charCodeAt();
    } else {
      return a[0] - b[0];
    }
  });

  let answer = 0;
  let count = 0;
  for (x of timeLine) {
    if (x[1] === "s") {
      count++;
      answer = Math.max(answer, count);
    } else {
      count--;
    }
  }
  return answer;
}

/* 회고
이번 문제는 어떻게 풀어야 될지 생각하는 데 오래 걸렸다.
이렇게 많은 사고가 필요한 문제는 오랜만에 푼 거 같다.
앞으로 어떻게 문제를 풀지 빠르게 생각을 해야겠다.
 */
