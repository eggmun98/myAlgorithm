/* 문제와 이해
배열을 오름차순으로 정렬해야 한다.
그리고 이분 탐색 알고리즘으로 target이 몇 번째 위치에 있는지 찾아야 한다.
 */

/* 계획
먼저 간단하게 sort 메소드를 이용하여 오름차순으로 정렬한다.
그리고 이분 탐색 알고리즘을 이용할 거다.
이분 탐색 알고리즘은 투 포인트 알고리즘과 비슷하다.
거기에 중간값이 포함된 알고리즘인 거다.
lP라는 제일 왼쪽의 시작 지점과
rP라는 제일 오른쪽의 시작 지점 포인트 변수들을 선언한다.
각각 0과 arr.length -1 값을 넣어준다.
그리고 while 문으로 lP와 rP가 겹쳐질 때까지 반복을 돌린다.
반복문을 돌 때마다 mP라는 중간값을 구한다.
중간값은 lP와 rP을 더한 값을 나눈 2의 값이다.
만약 배열의 mP 번째 요소와 target의 숫자가 같으면 몇 번째 인지 리턴한다.
만약 mP 번째 요소의 값이 target보다 작다면 mP 기준 왼쪽에 있는 배열의 요소들은 지운다.
그게 아니라 mP 번째 요소의 값이 target보다 크다면 mP 기준 오른쪽에 있는 배열의 요소들을 값을 지운다.
이런 식으로 계속 지우다 보면 마지막 하나의 target의 값을 찾을 수 있다.

*/

/* 풀이1
 */
function solution(target, arr) {
  arr.sort((a, b) => a - b);
  console.log(arr);
  let lP = 0;
  let rP = arr.length - 1;

  while (lP <= rP) {
    let mP = Math.floor((lP + rP) / 2);
    if (arr[mP] === target) return mP + 1;
    if (arr[mP] < target) {
      lP = mP + 1;
    } else {
      rP = mP - 1;
    }
  }
}

solution(target, arr);

/* 회고
이번 문제는 문제 제목에 나와 있는 것처럼 이분 검색으로 풀어야 한다.
그래서 이분 검색이 뭔지 알고리즘을 공부하였고,
평소에 보드게임하면서 많이 써본 알고리즘이라서,
코드로 바꾸는 작업을 하였다.
이번 문제로 이러한 중간값 찾기 알고리즘이 
이분 탐색이라는 이름이 있다는 것을 알게 되어 좋았다.
 */
