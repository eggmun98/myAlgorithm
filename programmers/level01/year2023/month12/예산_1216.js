// 1. 문제와 이해
// 먼저 신청 금액들을 작은 순서로 정렬해야 합니다.
// 그리고 작은 순서에서 budget금액과 같아지거나 커질때까지 count를 세야 합니다.

// 2. 계획
// d의 합산 값을 보관하는 sum 변수를 만든다.
// 몇개의 부서를 지원해 줄수 있는 count 변수를 만든다.
// 반복문을 돌린다.
// d의 길이 만큼 돌린다.
// 만약 budget 가 sum + d[i] 보다 클 경우 break를 해서
// count를 리턴한다. => 여기서 더 반복문을 돌릴 이유가 무의미해지기 때문이다.

// 3. 풀이
function solution(d, budget) {
  let sum = 0;
  let count = 0;
  d.sort((a, b) => a - b);

  for (let i = 0; i < d.length; i++) {
    if (budget < sum + d[i]) break;
    sum += d[i];
    count++;
  }
  return count;
}

// 4. 회고
// 이번 문제는 좀 더 나은 사고를 했으면 바로 풀었을 문제이다.
// 나는 처음 같을 경우만 신경써서 풀다 보니 답이 안나왔다.
// 또한 커질 경우에 바로 count 변수를 리턴하면
// 무의미한 계산을 더 안해도 되서 더 효율적인 것을 깨달았다.
// 앞으로도 더 효율적인 코드를 작성할 수 있게 노력해야 겠다.
