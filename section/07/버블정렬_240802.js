/* 문제와 이해
버블 정렬 알고리즘을 이용하여 오름차순 정렬을 해야 합니다.
 */

/* 계획
이중 반복문을 사용합니다.
첫 번째 반복문은 n - 1까지 진행합니다. 
왜나하면 마지막 요소는 이전 i 번째에서 검사를 하기 때문입니다.
두 번째 박복문은 n - 1 - i 번까지 진행합니다.
왜나하면 버블 정렬은 두 번째 반복문이 끝날 때 항상 마지막 요소가 제일 큰 숫자가 오기 때문입니다.
그러기 때문에 불필요한 계산은 필요 없습니다.
또 count라는 변수를 만듭니다.
두 번째 반복문에서 조건식이 통과될 때마다 count++ 시켜줍니다.
만약 두 번째 반복문이 종료되었을 때 
count라는 변수의 값이 선언 값 그대로라면
정렬을 안 했다는 뜻이므로 불필요한 반복문을 종료시킵니다.
*/

/* 풀이1
 */
function solution(arr, n) {
  for (let i = 0; i < n - 1; i++) {
    let count = 0;
    for (let j = 0; j < n - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]];
        count++;
      }
    }
    if (!count) return arr;
  }
  return arr;
}

/* 풀이2
 */
function solution(arr, n) {
  while (true) {
    let count = 0;
    for (let j = 0; j < n - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]];
        count++;
      }
    }
    if (!count) {
      return arr;
    }
  }
}

/* 회고
처음 이 문제를 풀 때 어떻게 풀지 많은 고민을 하였다.
특히 반복문의 조건식에서 어려움이 있었다.
그래서 언제 끝나야 될지 모르겠을 때는 while 문을 쓰라는 말이 있어서
while 문을 써서 풀었다.
하지만 아무리 생각해도 이건 불필요한 계산을 하고 있다고 판단을 하여
for 문을 이용하여 풀었다.
버블 정렬의 핵심은 항상 1회 차의 반복문이 끝날 때마다
마지막 요소에 가장 큰 숫자가 있게 된다.
이것을 깨닫고 나서 문제를 쉽게 풀게 되었다.
 */
