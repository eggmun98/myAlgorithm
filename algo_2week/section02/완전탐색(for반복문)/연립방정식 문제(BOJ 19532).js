// 1. 문제와 이해
// 설명: 두 개의 1차 연립방정식이 주어진다. 다음 식을 만족하는 (x, y)의 정수 해를 찾아야 한다.
//       a*x + b*y = c
//       d*x + e*y = f
// 입력: 6개의 정수 [a, b, c, d, e, f] (각 값은 -999 ~ 999)
// 출력: 정수 x, y (단, -10000 ≤ x, y ≤ 10000)
// 조건:
//   - 항상 해가 존재하며, 정수 해만 고려한다.
// 유형: 수학 / 연립방정식 / 교차 소거법

// 2. 계획
// 방법 A (브루트포스 완전탐색)
//   - x, y를 -10000 ~ 10000까지 모두 순회하며 식을 만족하는 해를 찾는다.
//   - 단점: 20001 * 20001 ≈ 4억 회 → 너무 비효율적 (실행 환경에 따라 막힘)
//
// 방법 B (수학적 접근 - 교차 소거법)
//   - 두 식을 동시에 풀어서 x, y를 직접 계산한다.
//     식 변환:
//       a*x + b*y = c
//       d*x + e*y = f
//     → x = (c*e - b*f) / (a*e - b*d)
//     → y = (a*f - c*d) / (a*e - b*d)
//   - 분모 (a*e - b*d)가 0이 되지 않음이 보장됨 (해가 존재하므로)
//   - x, y는 항상 정수로 떨어진다고 했으므로 그대로 출력 가능.
// 시간복잡도: O(1)
// 공간복잡도: O(1)

// 3. 풀이
/**
 * @param {number[]} input - [a, b, c, d, e, f]
 * @returns {[number, number]} (x, y)
 */
function solution(input) {
    const [a, b, c, d, e, f] = input;
  
    const denom = a * e - b * d;          // 분모
    const x = (c * e - b * f) / denom;    // x 구하기
    const y = (a * f - c * d) / denom;    // y 구하기
  
    console.log(x, y);
    return [x, y];
  }
  
  // 4. 테스트 케이스
  solution([1, 3, -1, 4, 1, 7]); // ✅ 출력: 2 -1
  solution([2, 5, 8, 3, -4, -11]); // ✅ 출력: 1 2