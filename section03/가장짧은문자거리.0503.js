// 한 개의 문자열 s와 문자 t가 주어지면 문자열 s의 각 문자가 문자 t와 떨어진 최소거리를 출 력하는 프로그램을 작성하세요.
// ▣ 입력설명
// 첫 번째 줄에 문자열 s와 문자 t가 주어진다. 문자열과 문자는 소문자로만 주어집니다. 문자열의 길이는 100을 넘지 않는다.
// ▣ 출력설명
// 첫 번째 줄에 각 문자열 s의 각 문자가 문자 t와 떨어진 거리를 순서대로 출력한다.
// ▣ 입력예제 1 teachermode e
// ▣ 출력예제 1 10121012210

// 내 풀이
const myFn = (str, bbq) => {
  let answer = "";
  let count = 0;
  let k = 0;
  for (let i = 0; i < str.length; i++) {
    count = 0;
    k = i;
    for (let j = i; j < 100; j++) {
      if (str[j] === bbq || str[k] === bbq) {
        answer += count;
        break;
      } else {
        count++;
        k--;
      }
    }
  }
  return answer;
};

myFn("teachermode", "e");

// 다른 사람 풀이
function solution(s, t) {
  let answer = [];
  let p = 1000;
  for (let x of s) {
    if (x === t) {
      p = 0;
      answer.push(p);
    } else {
      p++;
      answer.push(p);
    }
  }
  p = 1000;
  for (let i = s.length - 1; i >= 0; i--) {
    if (s[i] === t) p = 0;
    else {
      p++;
      answer[i] = Math.min(answer[i], p);
    }
  }
  return answer;
}

// 회고
// 이번 문제는 좀 어려웠던 문제였다.
// 겨우 풀고 나서 다른 사람 문제를 풀이를 보니 진짜 충격을 먹었다.
// 내 풀이는 문자열 길이가 10이면 반복문이 최대 100번 도는데
// 다른 사람풀이는 문자열 길이가 10이면 반복문이 20번만 돈다..
// 이중 for문과 for문 두번 썼을 때의 차이가 엄청 크다.
// 그리고 다른 사람 풀이를 해석하자면
// 왼쪽에서 오른쪽으로 한번 탐색하고
// 다시 오른쪽에서 왼쪽을 탐색하는거다.
// 즉 e를 만나면 0으로 초기화 안만나면 p++를 해준다.
// 그리고 왼쪽 탐색 결과값과 오른쪽 탐색 결과값을 비교한다.
// 비교하면서 작은값만 남겨둔다.
// 마지막으로 제일 포인트인 p를 1000으로 for문 처음 돌때마다 초기화 해준다.
// 왜나하면 만약 왼쪽 탐색부터 한다고 치자.
// 왼쪽 탐색을 할때 문자열 가장 첫번째가 e가 아니라면
// e와의 거리가 측정이 불가능하다.
// 그래서 p를 1000으로 초기화후 오른쪽 탐색 결과와 비교하여
// 문자열 첫번째 거리를 측정하는거다!!
